---
trigger: none
pr: none
variables:
- name: terraformVersion
  value: 1.6.0
- name: helmVersion
  value: 3.13.0
- name: azureServiceConnection
  value: Deploy
- name: dockerRegistryServiceConnection
  value: deploy-acr
- name: imageTag
  value: "$(Build.BuildId)"
- name: backendResourceGroupName
  value: rg-terraform-state
- name: backendStorageAccountName
  value: sttfstate16243d65
- name: backendContainerName
  value: tfstate
- name: backendKey
  value: aks-infrastructure.tfstate
stages:
- stage: Infrastructure
  displayName: Deploy Infrastructure
  jobs:
  - job: TerraformDeploy
    displayName: Deploy with Terraform
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
    - task: TerraformInstaller@0
      displayName: Install Terraform
      inputs:
        terraformVersion: "$(terraformVersion)"
    - task: AzureCLI@2
      displayName: Setup Terraform Backend
      inputs:
        azureSubscription: "$(azureServiceConnection)"
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          # Create the Resource Group and Storage Account for Terraform State if they don't exist
          az group create --name $(backendResourceGroupName) --location eastus
          az storage account create --name $(backendStorageAccountName) --resource-group $(backendResourceGroupName) --location eastus --sku Standard_LRS

          # Retrieve the key to create the container
          ACCOUNT_KEY=$(az storage account keys list --resource-group $(backendResourceGroupName) --account-name $(backendStorageAccountName) --query '[0].value' -o tsv)
          az storage container create --name $(backendContainerName) --account-name $(backendStorageAccountName) --account-key $ACCOUNT_KEY
    - task: AzureCLI@2
      displayName: Terraform Init & Apply
      name: terraformOutput
      inputs:
        azureSubscription: "$(azureServiceConnection)"
        scriptType: bash
        scriptLocation: inlineScript
        workingDirectory: "$(System.DefaultWorkingDirectory)/terraform"
        addSpnToEnvironment: true
        inlineScript: |
          # ----------------------------------------------------------------
          # AUTHENTICATION SETUP (Managed Identity Support)
          # ----------------------------------------------------------------

          # 1. Fetch Storage Key for the Backend
          # Terraform needs this to read/write the state file in the storage account.
          export ARM_ACCESS_KEY=$(az storage account keys list --resource-group $(backendResourceGroupName) --account-name $(backendStorageAccountName) --query '[0].value' -o tsv)

          # 2. Fetch Access Token for the Provider
          # Terraform needs this to create resources (AKS, etc.) using your Managed Identity.
          export ARM_ACCESS_TOKEN=$(az account get-access-token --resource REDACTED://management.azure.com/ --query accessToken -o tsv)

          # 3. Configure IDs
          export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
          export ARM_TENANT_ID=$(az account show --query tenantId -o tsv)
          export ARM_CLIENT_ID=$(az account show --query user.name -o tsv)

          # 4. Disable CLI Auth
          # We force Terraform to use the Token and Key we just exported, ignoring the CLI session.
          export ARM_USE_CLI=false
          export ARM_SKIP_PROVIDER_REGISTRATION=true

          # ----------------------------------------------------------------
          # TERRAFORM COMMANDS
          # ----------------------------------------------------------------

          # Init with reconfigure to handle any backend changes
          terraform init -reconfigure \
            -backend-config="resource_group_name=$(backendResourceGroupName)" \
            -backend-config="storage_account_name=$(backendStorageAccountName)" \
            -backend-config="container_name=$(backendContainerName)" \
            -backend-config="key=$(backendKey)"

          terraform plan -var-file="dev.tfvars" -out=tfplan
          terraform apply -auto-approve tfplan

          # ----------------------------------------------------------------
          # OUTPUTS
          # ----------------------------------------------------------------
          echo "##vso[task.setvariable variable=resourceGroupName;isOutput=true]$(terraform output -raw resource_group_name)"
          echo "##vso[task.setvariable variable=aksClusterName;isOutput=true]$(terraform output -raw aks_cluster_name)"
          echo "##vso[task.setvariable variable=acrName;isOutput=true]$(terraform output -raw acr_name)"
          echo "##vso[task.setvariable variable=acrLoginServer;isOutput=true]$(terraform output -raw acr_login_server)"
- stage: BuildImages
  displayName: Build Docker Images
  dependsOn: Infrastructure
  jobs:
  - job: BuildAll
    displayName: Build All Images
    pool:
      vmImage: ubuntu-latest
    steps:
    - task: Docker@2
      displayName: Build & Push Calculator
      inputs:
        command: buildAndPush
        repository: calculator
        dockerfile: calculator/Dockerfile
        containerRegistry: "$(dockerRegistryServiceConnection)"
        tags: |
          $(imageTag)
          latest
    - task: Docker@2
      displayName: Build & Push Weather
      inputs:
        command: buildAndPush
        repository: weather
        dockerfile: weather/Dockerfile
        containerRegistry: "$(dockerRegistryServiceConnection)"
        tags: |
          $(imageTag)
          latest
    - task: Docker@2
      displayName: Build & Push Traffic
      inputs:
        command: buildAndPush
        repository: traffic
        dockerfile: traffic/Dockerfile
        containerRegistry: "$(dockerRegistryServiceConnection)"
        tags: |
          $(imageTag)
          latest
- stage: DeployApps
  displayName: Deploy Applications
  dependsOn:
  - Infrastructure
  - BuildImages
  variables:
    resourceGroupName: "$[ stageDependencies.Infrastructure.TerraformDeploy.outputs['terraformOutput.resourceGroupName']
      ]"
    aksClusterName: "$[ stageDependencies.Infrastructure.TerraformDeploy.outputs['terraformOutput.aksClusterName']
      ]"
    acrLoginServer: "$[ stageDependencies.Infrastructure.TerraformDeploy.outputs['terraformOutput.acrLoginServer']
      ]"
  jobs:
  - deployment: Deploy
    displayName: Deploy to AKS
    pool:
      vmImage: ubuntu-latest
    environment: AKS-Production
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - task: HelmInstaller@1
            inputs:
              helmVersionToInstall: "$(helmVersion)"
          - task: AzureCLI@2
            displayName: Deploy Applications
            inputs:
              azureSubscription: "$(azureServiceConnection)"
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |-
                # 1. Force a clean, fresh connection to the API server
                # The --overwrite-existing flag is critical here
                az aks get-credentials --resource-group $(resourceGroupName) --name $(aksClusterName) --admin --overwrite-existing

                # 2. Add a Pre-Check to verify API connectivity
                # This will fail fast if the cluster is unreachable, giving a better error than Helm
                kubectl cluster-info || { echo "Cluster unreachable"; exit 1; }

                # 3. Update Helm values
                sed -i "s|acrdevw52one.azurecr.io|$(acrLoginServer)|g" helm-charts/*/values.yaml
                sed -i "s|tag: \"v1\"|tag: \"$(imageTag)\"|g" helm-charts/*/values.yaml

                # 4. Deploy with increased timeout and automatic cleanup
                # --atomic: Rolls back if the deploy fails or times out
                # --timeout: Set to 10m to account for ImagePull latency
                # --cleanup-on-fail: Removes failed releases so they don't block next runs
                helm upgrade --install calculator ./helm-charts/calculator-chart --wait --atomic --cleanup-on-fail --timeout 10m
                helm upgrade --install weather ./helm-charts/weather-chart --wait --atomic --cleanup-on-fail --timeout 10m
                helm upgrade --install traffic ./helm-charts/traffic-chart --wait --atomic --cleanup-on-fail --timeout 10m

                kubectl get all
